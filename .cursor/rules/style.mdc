---
alwaysApply: true
---

🏗 Homo-Go 框架开发最佳实践指南（Kratos 集成版）
1. 项目整体架构
1.1 核心原则

优先复用 Kratos 提供的能力（log、config、transport、registry、app lifecycle）

Module 只关注领域逻辑，不要重复造 config/log 管理器

目录结构清晰分层：

configs/：由 Kratos config 管理（文件/etcd/nacos 等）

log/：封装 Kratos log.Logger

module/：只写业务模块（ModuleKit）

cmd/：入口，直接用 kratos.New() + wire.Build()

1.2 目录结构规范
homo-go/                    # 项目根目录
├── api/                    # 公共 API / Proto 定义
│   ├── entity/             
│   ├── metadata/           
│   └── rpc/                
├── cmd/                    # 可执行程序入口
│   ├── kratos/            
│   ├── protoc-gen-go-errors/
│   └── protoc-gen-go-http/  
├── configs/                # 配置文件
├── contrib/                # 第三方贡献模块
├── encoding/               
├── entity/                 
├── internal/               # 内部实现（不对外暴露）
├── log/                    # 日志封装
├── middleware/             # 中间件
├── module/                 # 业务模块管理（ModuleKit）
├── registry/               # 服务注册
├── route/                  # 路由模块
├── rpc/                    # RPC 层
├── selector/               
├── storage/                
├── transport/              # 传输层
└── go.mod                  

1.3 模块目录结构
module_name/                 
├── todo/                   # 6A 工作流任务文档
│   ├── todolist.md        
│   └── Task-XX-xxx.md     
├── interfaces.go           # 模块接口定义
├── types.go                # 类型/常量/错误码
├── wire.go                 # Wire 依赖注入（如需要）
├── registry.go             # 全局模块注册表（如需要）
├── manager.go              # 管理器实现（如需要）
├── module_name.go          # 核心业务逻辑 
├── module_name_test.go     # 测试文件
├── module_name_mock.go     # Mock 对象 
└── README.md               # 使用说明


文件规范：

interfaces.go → 所有公共接口

types.go → 类型、常量、错误定义

manager.go → 模块管理器（可选）

module_name.go → 核心逻辑

2. Kratos 生命周期与 Module 生命周期对齐

Kratos 提供了生命周期 Hook：

app.BeforeStart(func(ctx context.Context) error { ... })
app.AfterStart(func(ctx context.Context) error { ... })
app.BeforeStop(func(ctx context.Context) error { ... })
app.AfterStop(func(ctx context.Context) error { ... })


推荐的对齐方式：

Homo-Go Module	Kratos 生命周期	用途
Init	NewApp() 阶段	初始化模块（配置加载、依赖注入）
AfterAllInit	BeforeStart()	所有模块 Init 完成后再做依赖绑定
AfterStart	AfterStart()	注册到大厅、开启定时任务、准备对外服务
BeforeClose	BeforeStop()	刷数据、停止任务
AfterStop	AfterStop()	清理缓存、下线标记
3. 模块开发规范
3.1 模块接口
// interfaces.go
type Module interface {
    Name() string
    Init(ctx context.Context, logger log.Logger, cfg config.Config) error
    AfterAllInit(ctx context.Context)
    AfterStart(ctx context.Context)
    BeforeClose(ctx context.Context)
    AfterStop(ctx context.Context)
}

3.2 ModuleManager
type ModuleManager struct {
    modules []Module
    logger  *log.Helper
    cfg     config.Config
}

func NewModuleManager(logger log.Logger, cfg config.Config, mods []Module) *ModuleManager {
    return &ModuleManager{
        modules: mods,
        logger:  log.NewHelper(logger),
        cfg:     cfg,
    }
}

func (m *ModuleManager) RegisterToApp(app *kratos.App) {
    ctx := context.Background()
    for _, mod := range m.modules {
        if err := mod.Init(ctx, m.logger, m.cfg); err != nil {
            panic(err)
        }
    }

    app.BeforeStart(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.AfterAllInit(ctx)
        }
        return nil
    })

    app.AfterStart(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.AfterStart(ctx)
        }
        return nil
    })

    app.BeforeStop(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.BeforeClose(ctx)
        }
        return nil
    })

    app.AfterStop(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.AfterStop(ctx)
        }
        return nil
    })
}

4. 配置管理（复用 Kratos config）

使用 atomic.Value 保证热更新一致性：

type MyModule struct {
    cfg atomic.Value // *MyConfig
}

func (m *MyModule) Init(ctx context.Context, logger log.Logger, cfg config.Config) error {
    var c MyConfig
    if err := cfg.Scan(&c); err != nil {
        return err
    }
    m.cfg.Store(&c)

    cfg.Watch("my_module", func(key string, value config.Value) {
        var nc MyConfig
        if err := value.Scan(&nc); err == nil {
            m.cfg.Store(&nc)
        }
    })
    return nil
}

func (m *MyModule) doSomething() {
    cfg := m.cfg.Load().(*MyConfig)
    if cfg.Enable {
        ...
    }
}

5. 日志（复用 Kratos log）

统一打 module 标签：

type MyModule struct {
    log *log.Helper
}

func NewMyModule(logger log.Logger) *MyModule {
    return &MyModule{
        log: log.NewHelper(log.With(logger, "module", "my_module")),
    }
}

6. 错误码

模块错误码规则：<模块名>_<错误描述>，定义放在 types.go：

const (
    ErrInvalidConfig = "USER_INVALID_CONFIG"
    ErrLoginFailed   = "USER_LOGIN_FAILED"
)

var (
    ErrConfig = errors.New(400, ErrInvalidConfig, "invalid config")
    ErrLogin  = errors.New(401, ErrLoginFailed, "login failed")
)

7. 依赖注入（Wire）

用 wire.Slice 自动收集所有 Module：

var ModuleSet = wire.NewSet(
    NewUserModule,
    NewMatchModule,
    NewChatModule,
    wire.Slice(
        new(Module),
        NewUserModule,
        NewMatchModule,
        NewChatModule,
    ),
)

8. 游戏服务常见模块

UserModule：用户登录、会话管理

MatchModule：匹配系统

RoomModule：战斗房间管理

ChatModule：聊天频道

MailModule：离线邮件

所有模块都只实现 Module 接口，统一交给 ModuleManager 管理。

9. 最小可运行 Demo
// cmd/main.go
package main

import (
    "context"
    "github.com/go-kratos/kratos/v2"
    "github.com/go-kratos/kratos/v2/config"
    "github.com/go-kratos/kratos/v2/log"
)

type HelloModule struct {
    log *log.Helper
}

func NewHelloModule(logger log.Logger) *HelloModule {
    return &HelloModule{log: log.NewHelper(log.With(logger, "module", "hello"))}
}

func (h *HelloModule) Name() string { return "hello" }
func (h *HelloModule) Init(ctx context.Context, logger log.Logger, cfg config.Config) error {
    h.log.Info("Init")
    return nil
}
func (h *HelloModule) AfterAllInit(ctx context.Context) { h.log.Info("AfterAllInit") }
func (h *HelloModule) AfterStart(ctx context.Context)   { h.log.Info("AfterStart") }
func (h *HelloModule) BeforeClose(ctx context.Context)  { h.log.Info("BeforeClose") }
func (h *HelloModule) AfterStop(ctx context.Context)    { h.log.Info("AfterStop") }

func main() {
    logger := log.With(log.NewStdLogger(os.Stdout), "ts", log.DefaultTimestamp)
    cfg := config.New(config.WithSource()) // 简化
    mods := []Module{NewHelloModule(logger)}

    mm := NewModuleManager(logger, cfg, mods)
    app := kratos.New()
    mm.RegisterToApp(app)
    if err := app.Run(); err != nil {
        panic(err)
    }
}🏗 Homo-Go 框架开发最佳实践指南（Kratos 集成版）
1. 项目整体架构
1.1 核心原则

优先复用 Kratos 提供的能力（log、config、transport、registry、app lifecycle）

Module 只关注领域逻辑，不要重复造 config/log 管理器

目录结构清晰分层：

configs/：由 Kratos config 管理（文件/etcd/nacos 等）

log/：封装 Kratos log.Logger

module/：只写业务模块（ModuleKit）

cmd/：入口，直接用 kratos.New() + wire.Build()

1.2 目录结构规范
homo-go/                    # 项目根目录
├── api/                    # 公共 API / Proto 定义
│   ├── entity/             
│   ├── metadata/           
│   └── rpc/                
├── cmd/                    # 可执行程序入口
│   ├── kratos/            
│   ├── protoc-gen-go-errors/
│   └── protoc-gen-go-http/  
├── configs/                # 配置文件
├── contrib/                # 第三方贡献模块
├── encoding/               
├── entity/                 
├── internal/               # 内部实现（不对外暴露）
├── log/                    # 日志封装
├── middleware/             # 中间件
├── module/                 # 业务模块管理（ModuleKit）
├── registry/               # 服务注册
├── route/                  # 路由模块
├── rpc/                    # RPC 层
├── selector/               
├── storage/                
├── transport/              # 传输层
└── go.mod                  

1.3 模块目录结构
module_name/                 
├── todo/                   # 6A 工作流任务文档
│   ├── todolist.md        
│   └── Task-XX-xxx.md     
├── interfaces.go           # 模块接口定义
├── types.go                # 类型/常量/错误码
├── wire.go                 # Wire 依赖注入
├── manager.go              # 管理器实现（如需要）
├── module_name.go          # 核心业务逻辑
├── config.go               # 配置管理 
├── module_name_test.go     # 测试文件
├── module_name_mock.go     # Mock 对象 
└── README.md               # 使用说明


文件规范：

interfaces.go → 所有公共接口

types.go → 类型、常量、错误定义

manager.go → 模块管理器（可选）

module_name.go → 核心逻辑

2. Kratos 生命周期与 Module 生命周期对齐

Kratos 提供了生命周期 Hook：

app.BeforeStart(func(ctx context.Context) error { ... })
app.AfterStart(func(ctx context.Context) error { ... })
app.BeforeStop(func(ctx context.Context) error { ... })
app.AfterStop(func(ctx context.Context) error { ... })


推荐的对齐方式：

Homo-Go Module	Kratos 生命周期	用途
Init	NewApp() 阶段	初始化模块（配置加载、依赖注入）
AfterAllInit	BeforeStart()	所有模块 Init 完成后再做依赖绑定
AfterStart	AfterStart()	注册到大厅、开启定时任务、准备对外服务
BeforeClose	BeforeStop()	刷数据、停止任务
AfterStop	AfterStop()	清理缓存、下线标记
3. 模块开发规范
3.1 模块接口
// interfaces.go
type Module interface {
    Name() string
    Init(ctx context.Context, logger log.Logger, cfg config.Config) error
    AfterAllInit(ctx context.Context)
    AfterStart(ctx context.Context)
    BeforeClose(ctx context.Context)
    AfterStop(ctx context.Context)
}

3.2 ModuleManager
type ModuleManager struct {
    modules []Module
    logger  *log.Helper
    cfg     config.Config
}

func NewModuleManager(logger log.Logger, cfg config.Config, mods []Module) *ModuleManager {
    return &ModuleManager{
        modules: mods,
        logger:  log.NewHelper(logger),
        cfg:     cfg,
    }
}

func (m *ModuleManager) RegisterToApp(app *kratos.App) {
    ctx := context.Background()
    for _, mod := range m.modules {
        if err := mod.Init(ctx, m.logger, m.cfg); err != nil {
            panic(err)
        }
    }

    app.BeforeStart(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.AfterAllInit(ctx)
        }
        return nil
    })

    app.AfterStart(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.AfterStart(ctx)
        }
        return nil
    })

    app.BeforeStop(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.BeforeClose(ctx)
        }
        return nil
    })

    app.AfterStop(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.AfterStop(ctx)
        }
        return nil
    })
}

4. 配置管理（复用 Kratos config）

使用 atomic.Value 保证热更新一致性：

type MyModule struct {
    cfg atomic.Value // *MyConfig
}

func (m *MyModule) Init(ctx context.Context, logger log.Logger, cfg config.Config) error {
    var c MyConfig
    if err := cfg.Scan(&c); err != nil {
        return err
    }
    m.cfg.Store(&c)

    cfg.Watch("my_module", func(key string, value config.Value) {
        var nc MyConfig
        if err := value.Scan(&nc); err == nil {
            m.cfg.Store(&nc)
        }
    })
    return nil
}

func (m *MyModule) doSomething() {
    cfg := m.cfg.Load().(*MyConfig)
    if cfg.Enable {
        ...
    }
}

5. 日志（复用 Kratos log）

统一打 module 标签：

type MyModule struct {
    log *log.Helper
}

func NewMyModule(logger log.Logger) *MyModule {
    return &MyModule{
        log: log.NewHelper(log.With(logger, "module", "my_module")),
    }
}

6. 错误码

模块错误码规则：<模块名>_<错误描述>，定义放在 types.go：

const (
    ErrInvalidConfig = "USER_INVALID_CONFIG"
    ErrLoginFailed   = "USER_LOGIN_FAILED"
)

var (
    ErrConfig = errors.New(400, ErrInvalidConfig, "invalid config")
    ErrLogin  = errors.New(401, ErrLoginFailed, "login failed")
)

7. 依赖注入（Wire）

用 wire.Slice 自动收集所有 Module：

var ModuleSet = wire.NewSet(
    NewUserModule,
    NewMatchModule,
    NewChatModule,
    wire.Slice(
        new(Module),
        NewUserModule,
        NewMatchModule,
        NewChatModule,
    ),
)

8. 游戏服务常见模块

UserModule：用户登录、会话管理

MatchModule：匹配系统

RoomModule：战斗房间管理

ChatModule：聊天频道

MailModule：离线邮件

所有模块都只实现 Module 接口，统一交给 ModuleManager 管理。

9. 最小可运行 Demo
// cmd/main.go
package main

import (
    "context"
    "github.com/go-kratos/kratos/v2"
    "github.com/go-kratos/kratos/v2/config"
    "github.com/go-kratos/kratos/v2/log"
)

type HelloModule struct {
    log *log.Helper
}

func NewHelloModule(logger log.Logger) *HelloModule {
    return &HelloModule{log: log.NewHelper(log.With(logger, "module", "hello"))}
}

func (h *HelloModule) Name() string { return "hello" }
func (h *HelloModule) Init(ctx context.Context, logger log.Logger, cfg config.Config) error {
    h.log.Info("Init")
    return nil
}
func (h *HelloModule) AfterAllInit(ctx context.Context) { h.log.Info("AfterAllInit") }
func (h *HelloModule) AfterStart(ctx context.Context)   { h.log.Info("AfterStart") }
func (h *HelloModule) BeforeClose(ctx context.Context)  { h.log.Info("BeforeClose") }
func (h *HelloModule) AfterStop(ctx context.Context)    { h.log.Info("AfterStop") }

func main() {
    logger := log.With(log.NewStdLogger(os.Stdout), "ts", log.DefaultTimestamp)
    cfg := config.New(config.WithSource()) // 简化
    mods := []Module{NewHelloModule(logger)}

    mm := NewModuleManager(logger, cfg, mods)
    app := kratos.New()
    mm.RegisterToApp(app)
    if err := app.Run(); err != nil {
        panic(err)
    }
}