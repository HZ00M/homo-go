---
alwaysApply: true
---

ğŸ— Homo-Go æ¡†æ¶å¼€å‘æœ€ä½³å®è·µæŒ‡å—ï¼ˆKratos é›†æˆç‰ˆï¼‰
1. é¡¹ç›®æ•´ä½“æ¶æ„
1.1 æ ¸å¿ƒåŸåˆ™

ä¼˜å…ˆå¤ç”¨ Kratos æä¾›çš„èƒ½åŠ›ï¼ˆlogã€configã€transportã€registryã€app lifecycleï¼‰

Module åªå…³æ³¨é¢†åŸŸé€»è¾‘ï¼Œä¸è¦é‡å¤é€  config/log ç®¡ç†å™¨

ç›®å½•ç»“æ„æ¸…æ™°åˆ†å±‚ï¼š

configs/ï¼šç”± Kratos config ç®¡ç†ï¼ˆæ–‡ä»¶/etcd/nacos ç­‰ï¼‰

log/ï¼šå°è£… Kratos log.Logger

module/ï¼šåªå†™ä¸šåŠ¡æ¨¡å—ï¼ˆModuleKitï¼‰

cmd/ï¼šå…¥å£ï¼Œç›´æ¥ç”¨ kratos.New() + wire.Build()

1.2 ç›®å½•ç»“æ„è§„èŒƒ
homo-go/                    # é¡¹ç›®æ ¹ç›®å½•
â”œâ”€â”€ api/                    # å…¬å…± API / Proto å®šä¹‰
â”‚   â”œâ”€â”€ entity/             
â”‚   â”œâ”€â”€ metadata/           
â”‚   â””â”€â”€ rpc/                
â”œâ”€â”€ cmd/                    # å¯æ‰§è¡Œç¨‹åºå…¥å£
â”‚   â”œâ”€â”€ kratos/            
â”‚   â”œâ”€â”€ protoc-gen-go-errors/
â”‚   â””â”€â”€ protoc-gen-go-http/  
â”œâ”€â”€ configs/                # é…ç½®æ–‡ä»¶
â”œâ”€â”€ contrib/                # ç¬¬ä¸‰æ–¹è´¡çŒ®æ¨¡å—
â”œâ”€â”€ encoding/               
â”œâ”€â”€ entity/                 
â”œâ”€â”€ internal/               # å†…éƒ¨å®ç°ï¼ˆä¸å¯¹å¤–æš´éœ²ï¼‰
â”œâ”€â”€ log/                    # æ—¥å¿—å°è£…
â”œâ”€â”€ middleware/             # ä¸­é—´ä»¶
â”œâ”€â”€ module/                 # ä¸šåŠ¡æ¨¡å—ç®¡ç†ï¼ˆModuleKitï¼‰
â”œâ”€â”€ registry/               # æœåŠ¡æ³¨å†Œ
â”œâ”€â”€ route/                  # è·¯ç”±æ¨¡å—
â”œâ”€â”€ rpc/                    # RPC å±‚
â”œâ”€â”€ selector/               
â”œâ”€â”€ storage/                
â”œâ”€â”€ transport/              # ä¼ è¾“å±‚
â””â”€â”€ go.mod                  

1.3 æ¨¡å—ç›®å½•ç»“æ„
module_name/                 
â”œâ”€â”€ todo/                   # 6A å·¥ä½œæµä»»åŠ¡æ–‡æ¡£
â”‚   â”œâ”€â”€ todolist.md        
â”‚   â””â”€â”€ Task-XX-xxx.md     
â”œâ”€â”€ interfaces.go           # æ¨¡å—æ¥å£å®šä¹‰
â”œâ”€â”€ types.go                # ç±»å‹/å¸¸é‡/é”™è¯¯ç 
â”œâ”€â”€ wire.go                 # Wire ä¾èµ–æ³¨å…¥ï¼ˆå¦‚éœ€è¦ï¼‰
â”œâ”€â”€ registry.go             # å…¨å±€æ¨¡å—æ³¨å†Œè¡¨ï¼ˆå¦‚éœ€è¦ï¼‰
â”œâ”€â”€ manager.go              # ç®¡ç†å™¨å®ç°ï¼ˆå¦‚éœ€è¦ï¼‰
â”œâ”€â”€ module_name.go          # æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ 
â”œâ”€â”€ module_name_test.go     # æµ‹è¯•æ–‡ä»¶
â”œâ”€â”€ module_name_mock.go     # Mock å¯¹è±¡ 
â””â”€â”€ README.md               # ä½¿ç”¨è¯´æ˜


æ–‡ä»¶è§„èŒƒï¼š

interfaces.go â†’ æ‰€æœ‰å…¬å…±æ¥å£

types.go â†’ ç±»å‹ã€å¸¸é‡ã€é”™è¯¯å®šä¹‰

manager.go â†’ æ¨¡å—ç®¡ç†å™¨ï¼ˆå¯é€‰ï¼‰

module_name.go â†’ æ ¸å¿ƒé€»è¾‘

2. Kratos ç”Ÿå‘½å‘¨æœŸä¸ Module ç”Ÿå‘½å‘¨æœŸå¯¹é½

Kratos æä¾›äº†ç”Ÿå‘½å‘¨æœŸ Hookï¼š

app.BeforeStart(func(ctx context.Context) error { ... })
app.AfterStart(func(ctx context.Context) error { ... })
app.BeforeStop(func(ctx context.Context) error { ... })
app.AfterStop(func(ctx context.Context) error { ... })


æ¨èçš„å¯¹é½æ–¹å¼ï¼š

Homo-Go Module	Kratos ç”Ÿå‘½å‘¨æœŸ	ç”¨é€”
Init	NewApp() é˜¶æ®µ	åˆå§‹åŒ–æ¨¡å—ï¼ˆé…ç½®åŠ è½½ã€ä¾èµ–æ³¨å…¥ï¼‰
AfterAllInit	BeforeStart()	æ‰€æœ‰æ¨¡å— Init å®Œæˆåå†åšä¾èµ–ç»‘å®š
AfterStart	AfterStart()	æ³¨å†Œåˆ°å¤§å…ã€å¼€å¯å®šæ—¶ä»»åŠ¡ã€å‡†å¤‡å¯¹å¤–æœåŠ¡
BeforeClose	BeforeStop()	åˆ·æ•°æ®ã€åœæ­¢ä»»åŠ¡
AfterStop	AfterStop()	æ¸…ç†ç¼“å­˜ã€ä¸‹çº¿æ ‡è®°
3. æ¨¡å—å¼€å‘è§„èŒƒ
3.1 æ¨¡å—æ¥å£
// interfaces.go
type Module interface {
    Name() string
    Init(ctx context.Context, logger log.Logger, cfg config.Config) error
    AfterAllInit(ctx context.Context)
    AfterStart(ctx context.Context)
    BeforeClose(ctx context.Context)
    AfterStop(ctx context.Context)
}

3.2 ModuleManager
type ModuleManager struct {
    modules []Module
    logger  *log.Helper
    cfg     config.Config
}

func NewModuleManager(logger log.Logger, cfg config.Config, mods []Module) *ModuleManager {
    return &ModuleManager{
        modules: mods,
        logger:  log.NewHelper(logger),
        cfg:     cfg,
    }
}

func (m *ModuleManager) RegisterToApp(app *kratos.App) {
    ctx := context.Background()
    for _, mod := range m.modules {
        if err := mod.Init(ctx, m.logger, m.cfg); err != nil {
            panic(err)
        }
    }

    app.BeforeStart(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.AfterAllInit(ctx)
        }
        return nil
    })

    app.AfterStart(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.AfterStart(ctx)
        }
        return nil
    })

    app.BeforeStop(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.BeforeClose(ctx)
        }
        return nil
    })

    app.AfterStop(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.AfterStop(ctx)
        }
        return nil
    })
}

4. é…ç½®ç®¡ç†ï¼ˆå¤ç”¨ Kratos configï¼‰

ä½¿ç”¨ atomic.Value ä¿è¯çƒ­æ›´æ–°ä¸€è‡´æ€§ï¼š

type MyModule struct {
    cfg atomic.Value // *MyConfig
}

func (m *MyModule) Init(ctx context.Context, logger log.Logger, cfg config.Config) error {
    var c MyConfig
    if err := cfg.Scan(&c); err != nil {
        return err
    }
    m.cfg.Store(&c)

    cfg.Watch("my_module", func(key string, value config.Value) {
        var nc MyConfig
        if err := value.Scan(&nc); err == nil {
            m.cfg.Store(&nc)
        }
    })
    return nil
}

func (m *MyModule) doSomething() {
    cfg := m.cfg.Load().(*MyConfig)
    if cfg.Enable {
        ...
    }
}

5. æ—¥å¿—ï¼ˆå¤ç”¨ Kratos logï¼‰

ç»Ÿä¸€æ‰“ module æ ‡ç­¾ï¼š

type MyModule struct {
    log *log.Helper
}

func NewMyModule(logger log.Logger) *MyModule {
    return &MyModule{
        log: log.NewHelper(log.With(logger, "module", "my_module")),
    }
}

6. é”™è¯¯ç 

æ¨¡å—é”™è¯¯ç è§„åˆ™ï¼š<æ¨¡å—å>_<é”™è¯¯æè¿°>ï¼Œå®šä¹‰æ”¾åœ¨ types.goï¼š

const (
    ErrInvalidConfig = "USER_INVALID_CONFIG"
    ErrLoginFailed   = "USER_LOGIN_FAILED"
)

var (
    ErrConfig = errors.New(400, ErrInvalidConfig, "invalid config")
    ErrLogin  = errors.New(401, ErrLoginFailed, "login failed")
)

7. ä¾èµ–æ³¨å…¥ï¼ˆWireï¼‰

ç”¨ wire.Slice è‡ªåŠ¨æ”¶é›†æ‰€æœ‰ Moduleï¼š

var ModuleSet = wire.NewSet(
    NewUserModule,
    NewMatchModule,
    NewChatModule,
    wire.Slice(
        new(Module),
        NewUserModule,
        NewMatchModule,
        NewChatModule,
    ),
)

8. æ¸¸æˆæœåŠ¡å¸¸è§æ¨¡å—

UserModuleï¼šç”¨æˆ·ç™»å½•ã€ä¼šè¯ç®¡ç†

MatchModuleï¼šåŒ¹é…ç³»ç»Ÿ

RoomModuleï¼šæˆ˜æ–—æˆ¿é—´ç®¡ç†

ChatModuleï¼šèŠå¤©é¢‘é“

MailModuleï¼šç¦»çº¿é‚®ä»¶

æ‰€æœ‰æ¨¡å—éƒ½åªå®ç° Module æ¥å£ï¼Œç»Ÿä¸€äº¤ç»™ ModuleManager ç®¡ç†ã€‚

9. æœ€å°å¯è¿è¡Œ Demo
// cmd/main.go
package main

import (
    "context"
    "github.com/go-kratos/kratos/v2"
    "github.com/go-kratos/kratos/v2/config"
    "github.com/go-kratos/kratos/v2/log"
)

type HelloModule struct {
    log *log.Helper
}

func NewHelloModule(logger log.Logger) *HelloModule {
    return &HelloModule{log: log.NewHelper(log.With(logger, "module", "hello"))}
}

func (h *HelloModule) Name() string { return "hello" }
func (h *HelloModule) Init(ctx context.Context, logger log.Logger, cfg config.Config) error {
    h.log.Info("Init")
    return nil
}
func (h *HelloModule) AfterAllInit(ctx context.Context) { h.log.Info("AfterAllInit") }
func (h *HelloModule) AfterStart(ctx context.Context)   { h.log.Info("AfterStart") }
func (h *HelloModule) BeforeClose(ctx context.Context)  { h.log.Info("BeforeClose") }
func (h *HelloModule) AfterStop(ctx context.Context)    { h.log.Info("AfterStop") }

func main() {
    logger := log.With(log.NewStdLogger(os.Stdout), "ts", log.DefaultTimestamp)
    cfg := config.New(config.WithSource()) // ç®€åŒ–
    mods := []Module{NewHelloModule(logger)}

    mm := NewModuleManager(logger, cfg, mods)
    app := kratos.New()
    mm.RegisterToApp(app)
    if err := app.Run(); err != nil {
        panic(err)
    }
}ğŸ— Homo-Go æ¡†æ¶å¼€å‘æœ€ä½³å®è·µæŒ‡å—ï¼ˆKratos é›†æˆç‰ˆï¼‰
1. é¡¹ç›®æ•´ä½“æ¶æ„
1.1 æ ¸å¿ƒåŸåˆ™

ä¼˜å…ˆå¤ç”¨ Kratos æä¾›çš„èƒ½åŠ›ï¼ˆlogã€configã€transportã€registryã€app lifecycleï¼‰

Module åªå…³æ³¨é¢†åŸŸé€»è¾‘ï¼Œä¸è¦é‡å¤é€  config/log ç®¡ç†å™¨

ç›®å½•ç»“æ„æ¸…æ™°åˆ†å±‚ï¼š

configs/ï¼šç”± Kratos config ç®¡ç†ï¼ˆæ–‡ä»¶/etcd/nacos ç­‰ï¼‰

log/ï¼šå°è£… Kratos log.Logger

module/ï¼šåªå†™ä¸šåŠ¡æ¨¡å—ï¼ˆModuleKitï¼‰

cmd/ï¼šå…¥å£ï¼Œç›´æ¥ç”¨ kratos.New() + wire.Build()

1.2 ç›®å½•ç»“æ„è§„èŒƒ
homo-go/                    # é¡¹ç›®æ ¹ç›®å½•
â”œâ”€â”€ api/                    # å…¬å…± API / Proto å®šä¹‰
â”‚   â”œâ”€â”€ entity/             
â”‚   â”œâ”€â”€ metadata/           
â”‚   â””â”€â”€ rpc/                
â”œâ”€â”€ cmd/                    # å¯æ‰§è¡Œç¨‹åºå…¥å£
â”‚   â”œâ”€â”€ kratos/            
â”‚   â”œâ”€â”€ protoc-gen-go-errors/
â”‚   â””â”€â”€ protoc-gen-go-http/  
â”œâ”€â”€ configs/                # é…ç½®æ–‡ä»¶
â”œâ”€â”€ contrib/                # ç¬¬ä¸‰æ–¹è´¡çŒ®æ¨¡å—
â”œâ”€â”€ encoding/               
â”œâ”€â”€ entity/                 
â”œâ”€â”€ internal/               # å†…éƒ¨å®ç°ï¼ˆä¸å¯¹å¤–æš´éœ²ï¼‰
â”œâ”€â”€ log/                    # æ—¥å¿—å°è£…
â”œâ”€â”€ middleware/             # ä¸­é—´ä»¶
â”œâ”€â”€ module/                 # ä¸šåŠ¡æ¨¡å—ç®¡ç†ï¼ˆModuleKitï¼‰
â”œâ”€â”€ registry/               # æœåŠ¡æ³¨å†Œ
â”œâ”€â”€ route/                  # è·¯ç”±æ¨¡å—
â”œâ”€â”€ rpc/                    # RPC å±‚
â”œâ”€â”€ selector/               
â”œâ”€â”€ storage/                
â”œâ”€â”€ transport/              # ä¼ è¾“å±‚
â””â”€â”€ go.mod                  

1.3 æ¨¡å—ç›®å½•ç»“æ„
module_name/                 
â”œâ”€â”€ todo/                   # 6A å·¥ä½œæµä»»åŠ¡æ–‡æ¡£
â”‚   â”œâ”€â”€ todolist.md        
â”‚   â””â”€â”€ Task-XX-xxx.md     
â”œâ”€â”€ interfaces.go           # æ¨¡å—æ¥å£å®šä¹‰
â”œâ”€â”€ types.go                # ç±»å‹/å¸¸é‡/é”™è¯¯ç 
â”œâ”€â”€ wire.go                 # Wire ä¾èµ–æ³¨å…¥
â”œâ”€â”€ manager.go              # ç®¡ç†å™¨å®ç°ï¼ˆå¦‚éœ€è¦ï¼‰
â”œâ”€â”€ module_name.go          # æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
â”œâ”€â”€ config.go               # é…ç½®ç®¡ç† 
â”œâ”€â”€ module_name_test.go     # æµ‹è¯•æ–‡ä»¶
â”œâ”€â”€ module_name_mock.go     # Mock å¯¹è±¡ 
â””â”€â”€ README.md               # ä½¿ç”¨è¯´æ˜


æ–‡ä»¶è§„èŒƒï¼š

interfaces.go â†’ æ‰€æœ‰å…¬å…±æ¥å£

types.go â†’ ç±»å‹ã€å¸¸é‡ã€é”™è¯¯å®šä¹‰

manager.go â†’ æ¨¡å—ç®¡ç†å™¨ï¼ˆå¯é€‰ï¼‰

module_name.go â†’ æ ¸å¿ƒé€»è¾‘

2. Kratos ç”Ÿå‘½å‘¨æœŸä¸ Module ç”Ÿå‘½å‘¨æœŸå¯¹é½

Kratos æä¾›äº†ç”Ÿå‘½å‘¨æœŸ Hookï¼š

app.BeforeStart(func(ctx context.Context) error { ... })
app.AfterStart(func(ctx context.Context) error { ... })
app.BeforeStop(func(ctx context.Context) error { ... })
app.AfterStop(func(ctx context.Context) error { ... })


æ¨èçš„å¯¹é½æ–¹å¼ï¼š

Homo-Go Module	Kratos ç”Ÿå‘½å‘¨æœŸ	ç”¨é€”
Init	NewApp() é˜¶æ®µ	åˆå§‹åŒ–æ¨¡å—ï¼ˆé…ç½®åŠ è½½ã€ä¾èµ–æ³¨å…¥ï¼‰
AfterAllInit	BeforeStart()	æ‰€æœ‰æ¨¡å— Init å®Œæˆåå†åšä¾èµ–ç»‘å®š
AfterStart	AfterStart()	æ³¨å†Œåˆ°å¤§å…ã€å¼€å¯å®šæ—¶ä»»åŠ¡ã€å‡†å¤‡å¯¹å¤–æœåŠ¡
BeforeClose	BeforeStop()	åˆ·æ•°æ®ã€åœæ­¢ä»»åŠ¡
AfterStop	AfterStop()	æ¸…ç†ç¼“å­˜ã€ä¸‹çº¿æ ‡è®°
3. æ¨¡å—å¼€å‘è§„èŒƒ
3.1 æ¨¡å—æ¥å£
// interfaces.go
type Module interface {
    Name() string
    Init(ctx context.Context, logger log.Logger, cfg config.Config) error
    AfterAllInit(ctx context.Context)
    AfterStart(ctx context.Context)
    BeforeClose(ctx context.Context)
    AfterStop(ctx context.Context)
}

3.2 ModuleManager
type ModuleManager struct {
    modules []Module
    logger  *log.Helper
    cfg     config.Config
}

func NewModuleManager(logger log.Logger, cfg config.Config, mods []Module) *ModuleManager {
    return &ModuleManager{
        modules: mods,
        logger:  log.NewHelper(logger),
        cfg:     cfg,
    }
}

func (m *ModuleManager) RegisterToApp(app *kratos.App) {
    ctx := context.Background()
    for _, mod := range m.modules {
        if err := mod.Init(ctx, m.logger, m.cfg); err != nil {
            panic(err)
        }
    }

    app.BeforeStart(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.AfterAllInit(ctx)
        }
        return nil
    })

    app.AfterStart(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.AfterStart(ctx)
        }
        return nil
    })

    app.BeforeStop(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.BeforeClose(ctx)
        }
        return nil
    })

    app.AfterStop(func(ctx context.Context) error {
        for _, mod := range m.modules {
            mod.AfterStop(ctx)
        }
        return nil
    })
}

4. é…ç½®ç®¡ç†ï¼ˆå¤ç”¨ Kratos configï¼‰

ä½¿ç”¨ atomic.Value ä¿è¯çƒ­æ›´æ–°ä¸€è‡´æ€§ï¼š

type MyModule struct {
    cfg atomic.Value // *MyConfig
}

func (m *MyModule) Init(ctx context.Context, logger log.Logger, cfg config.Config) error {
    var c MyConfig
    if err := cfg.Scan(&c); err != nil {
        return err
    }
    m.cfg.Store(&c)

    cfg.Watch("my_module", func(key string, value config.Value) {
        var nc MyConfig
        if err := value.Scan(&nc); err == nil {
            m.cfg.Store(&nc)
        }
    })
    return nil
}

func (m *MyModule) doSomething() {
    cfg := m.cfg.Load().(*MyConfig)
    if cfg.Enable {
        ...
    }
}

5. æ—¥å¿—ï¼ˆå¤ç”¨ Kratos logï¼‰

ç»Ÿä¸€æ‰“ module æ ‡ç­¾ï¼š

type MyModule struct {
    log *log.Helper
}

func NewMyModule(logger log.Logger) *MyModule {
    return &MyModule{
        log: log.NewHelper(log.With(logger, "module", "my_module")),
    }
}

6. é”™è¯¯ç 

æ¨¡å—é”™è¯¯ç è§„åˆ™ï¼š<æ¨¡å—å>_<é”™è¯¯æè¿°>ï¼Œå®šä¹‰æ”¾åœ¨ types.goï¼š

const (
    ErrInvalidConfig = "USER_INVALID_CONFIG"
    ErrLoginFailed   = "USER_LOGIN_FAILED"
)

var (
    ErrConfig = errors.New(400, ErrInvalidConfig, "invalid config")
    ErrLogin  = errors.New(401, ErrLoginFailed, "login failed")
)

7. ä¾èµ–æ³¨å…¥ï¼ˆWireï¼‰

ç”¨ wire.Slice è‡ªåŠ¨æ”¶é›†æ‰€æœ‰ Moduleï¼š

var ModuleSet = wire.NewSet(
    NewUserModule,
    NewMatchModule,
    NewChatModule,
    wire.Slice(
        new(Module),
        NewUserModule,
        NewMatchModule,
        NewChatModule,
    ),
)

8. æ¸¸æˆæœåŠ¡å¸¸è§æ¨¡å—

UserModuleï¼šç”¨æˆ·ç™»å½•ã€ä¼šè¯ç®¡ç†

MatchModuleï¼šåŒ¹é…ç³»ç»Ÿ

RoomModuleï¼šæˆ˜æ–—æˆ¿é—´ç®¡ç†

ChatModuleï¼šèŠå¤©é¢‘é“

MailModuleï¼šç¦»çº¿é‚®ä»¶

æ‰€æœ‰æ¨¡å—éƒ½åªå®ç° Module æ¥å£ï¼Œç»Ÿä¸€äº¤ç»™ ModuleManager ç®¡ç†ã€‚

9. æœ€å°å¯è¿è¡Œ Demo
// cmd/main.go
package main

import (
    "context"
    "github.com/go-kratos/kratos/v2"
    "github.com/go-kratos/kratos/v2/config"
    "github.com/go-kratos/kratos/v2/log"
)

type HelloModule struct {
    log *log.Helper
}

func NewHelloModule(logger log.Logger) *HelloModule {
    return &HelloModule{log: log.NewHelper(log.With(logger, "module", "hello"))}
}

func (h *HelloModule) Name() string { return "hello" }
func (h *HelloModule) Init(ctx context.Context, logger log.Logger, cfg config.Config) error {
    h.log.Info("Init")
    return nil
}
func (h *HelloModule) AfterAllInit(ctx context.Context) { h.log.Info("AfterAllInit") }
func (h *HelloModule) AfterStart(ctx context.Context)   { h.log.Info("AfterStart") }
func (h *HelloModule) BeforeClose(ctx context.Context)  { h.log.Info("BeforeClose") }
func (h *HelloModule) AfterStop(ctx context.Context)    { h.log.Info("AfterStop") }

func main() {
    logger := log.With(log.NewStdLogger(os.Stdout), "ts", log.DefaultTimestamp)
    cfg := config.New(config.WithSource()) // ç®€åŒ–
    mods := []Module{NewHelloModule(logger)}

    mm := NewModuleManager(logger, cfg, mods)
    app := kratos.New()
    mm.RegisterToApp(app)
    if err := app.Run(); err != nil {
        panic(err)
    }
}